"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+curves@1.2.0";
exports.ids = ["vendor-chunks/@noble+curves@1.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.3.2/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9FQUFvRSxHQUMxQjtBQUNxQjtBQUNQO0FBQ3hELHdDQUF3QztBQUNqQyxTQUFTSSxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFDSEE7UUFDQUwsTUFBTSxDQUFDTSxLQUFLLEdBQUdDLE9BQVNQLHdEQUFJQSxDQUFDSyxNQUFNQyxLQUFLTCxnRUFBV0EsSUFBSU07UUFDdkRMLFdBQVdBLDhEQUFBQTtJQUNmO0FBQ0o7QUFDTyxTQUFTTSxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDTixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdNLFFBQVE7WUFBRSxHQUFHTCxRQUFRQyxLQUFLO1FBQUM7SUFDckUsT0FBT08sT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR0YsT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3RELEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjMjBfd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS4yLjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/YTBlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwQkFBMEI7QUFDNEI7QUFDVjtBQUM1QyxNQUFNRyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsNkRBQTZEO0FBQzdELG1HQUFtRztBQUNuRyx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELCtFQUErRTtBQUMvRSxvR0FBb0c7QUFDcEcsb0dBQW9HO0FBQ3BHLHFDQUFxQztBQUNyQyxrR0FBa0c7QUFDbEcsZ0dBQWdHO0FBQ2hHLDhDQUE4QztBQUN2QyxTQUFTRSxLQUFLQyxDQUFDLEVBQUVDLElBQUk7SUFDeEIsTUFBTUMsa0JBQWtCLENBQUNDLFdBQVdDO1FBQ2hDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07UUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7SUFDN0I7SUFDQSxNQUFNRyxPQUFPLENBQUNDO1FBQ1YsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDVixPQUFPTyxLQUFLLEdBQUcsY0FBYztRQUN2RCxNQUFNSSxhQUFhLEtBQU1KLENBQUFBLElBQUksSUFBSSwwQkFBMEI7UUFDM0QsT0FBTztZQUFFQztZQUFTRztRQUFXO0lBQ2pDO0lBQ0EsT0FBTztRQUNIVjtRQUNBLHVDQUF1QztRQUN2Q1csY0FBYUMsR0FBRyxFQUFFQyxDQUFDO1lBQ2YsSUFBSUMsSUFBSWhCLEVBQUVpQixJQUFJO1lBQ2QsSUFBSUMsSUFBSUo7WUFDUixNQUFPQyxJQUFJbkIsSUFBSztnQkFDWixJQUFJbUIsSUFBSWpCLEtBQ0prQixJQUFJQSxFQUFFRyxHQUFHLENBQUNEO2dCQUNkQSxJQUFJQSxFQUFFRSxNQUFNO2dCQUNaTCxNQUFNakI7WUFDVjtZQUNBLE9BQU9rQjtRQUNYO1FBQ0E7Ozs7Ozs7OztTQVNDLEdB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SUFDL0J6RCwwREFBYUEsQ0FBQ3lELE1BQU1DLEVBQUU7SUFDdEJ4RCx5REFBY0EsQ0FBQ3VELE9BQU87UUFDbEJuQyxHQUFHO1FBQ0hxQyxHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUNqQixHQUFHaEUsb0RBQU9BLENBQUN3RCxNQUFNbkMsQ0FBQyxFQUFFbUMsTUFBTUssVUFBVSxDQUFDO1FBQ3JDLEdBQUdMLEtBQUs7UUFDUixHQUFHO1lBQUVsQyxHQUFHa0MsTUFBTUMsRUFBRSxDQUFDUSxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjMjBfd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS4yLjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzRjNjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVGaWVsZCIsIm5MZW5ndGgiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIndOQUYiLCJjIiwiYml0cyIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJvcHRzIiwiVyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ1bnNhZmVMYWRkZXIiLCJlbG0iLCJuIiwicCIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsInBvaW50cyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwiaSIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJtYXNrIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIm9mZnNldCIsIndiaXRzIiwiTnVtYmVyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwid05BRkNhY2hlZCIsIlAiLCJwcmVjb21wdXRlc01hcCIsInRyYW5zZm9ybSIsIl9XSU5ET1dfU0laRSIsImNvbXAiLCJnZXQiLCJzZXQiLCJ2YWxpZGF0ZUJhc2ljIiwiY3VydmUiLCJGcCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiT2JqZWN0IiwiZnJlZXplIiwiT1JERVIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsc0RBQXNEO0FBQ2lGO0FBQ3ZJLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU8sSUFBSU0sTUFBTU4sT0FBTztBQUNyRCxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTVAsT0FBTyxJQUFJUSxPQUFPUixPQUFPO0FBQ3JDLHdCQUF3QjtBQUNqQixTQUFTUyxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVWIsTUFBTWEsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7Q0FLQyxHQUNELG9DQUFvQztBQUM3QixTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxJQUFJQSxVQUFVakIsT0FBT2dCLFFBQVFoQixLQUN6QixNQUFNLElBQUlrQixNQUFNO0lBQ3BCLElBQUlELFdBQVdmLEtBQ1gsT0FBT0Y7SUFDWCxJQUFJbUIsTUFBTWpCO0lBQ1YsTUFBT2MsUUFBUWhCLElBQUs7UUFDaEIsSUFBSWdCLFFBQVFkLEtBQ1JpQixNQUFNLE1BQU9KLE1BQU9FO1FBQ3hCRixNQUFNLE1BQU9BLE1BQU9FO1FBQ3BCRCxVQUFVZDtJQUNkO0lBQ0EsT0FBT2lCO0FBQ1g7QUFDQSwwREFBMEQ7QUFDbkQsU0FBU0MsS0FBS0MsQ0FBQyxFQUFFTCxLQUFLLEVBQUVDLE1BQU07SUFDakMsSUFBSUUsTUFBTUU7SUFDVixNQUFPTCxVQUFV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ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz8zZjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbImJpdE1hc2siLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzhuIiwiXzluIiwiXzE2biIsIm1vZCIsImEiLCJiIiwicmVzdWx0IiwicG93IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJFcnJvciIsInJlcyIsInBvdzIiLCJ4IiwiaW52ZXJ0IiwibnVtYmVyIiwieSIsInUiLCJ2IiwicSIsInIiLCJtIiwibiIsImdjZCIsInRvbmVsbGlTaGFua3MiLCJQIiwibGVnZW5kcmVDIiwiUSIsIlMiLCJaIiwicDFkaXY0IiwidG9uZWxsaUZhc3QiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsIm5lZyIsIk9ORSIsImciLCJtdWwiLCJaRVJPIiwidDIiLCJnZSIsIkZwU3FydCIsInNxcnQzbW9kNCIsImMxIiwic3FydDVtb2Q4IiwibjIiLCJudiIsImkiLCJzdWIiLCJpc05lZ2F0aXZlTEUiLCJGSUVMRF9GSUVMRFMiLCJ2YWxpZGF0ZUZpZWxkIiwiZmllbGQiLCJpbml0aWFsIiwiT1JERVIiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsIkZwUG93IiwiZiIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJ0bXAiLCJBcnJheSIsImxlbmd0aCIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaXMwIiwiaW52ZXJ0ZWQiLCJpbnYiLCJyZWR1Y2VSaWdodCIsIkZwRGl2IiwibGhzIiwicmhzIiwiRnBJc1NxdWFyZSIsImxlZ2VuZHJlQ29uc3QiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiRmllbGQiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: () => (/* binding */ poseidon),\n/* harmony export */   splitConstants: () => (/* binding */ splitConstants),\n/* harmony export */   validateOpts: () => (/* binding */ validateOpts)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of [\n        \"t\",\n        \"roundsFull\",\n        \"roundsPartial\"\n    ]){\n        if (typeof opts[i] !== \"number\" || !Number.isSafeInteger(opts[i])) throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t) throw new Error(\"Poseidon: wrong MDS matrix\");\n    const _mds = mds.map((mdsRow)=>{\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t) throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i)=>{\n            if (typeof i !== \"bigint\") throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== \"boolean\") throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0) throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds) throw new Error(\"Poseidon: wrong round constants\");\n    const roundConstants = rc.map((rc)=>{\n        if (!Array.isArray(rc) || rc.length !== t) throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i)=>{\n            if (typeof i !== \"bigint\" || !Fp.isValid(i)) throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![\n        3,\n        5,\n        7\n    ].includes(sboxPower)) throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3) sboxFn = (n)=>Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5) sboxFn = (n)=>Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({\n        ...opts,\n        rounds,\n        sboxFn,\n        roundConstants,\n        mds: _mds\n    });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== \"number\") throw new Error(\"poseidonSplitConstants: wrong t\");\n    if (!Array.isArray(rc) || rc.length % t) throw new Error(\"poseidonSplitConstants: wrong rc\");\n    const res = [];\n    let tmp = [];\n    for(let i = 0; i < rc.length; i++){\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx)=>{\n        values = values.map((i, j)=>Fp.add(i, roundConstants[idx][j]));\n        if (isFull) values = values.map((i)=>sboxFn(i));\n        else values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i)=>i.reduce((acc, i, j)=>Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t) throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i)=>{\n            if (typeof i !== \"bigint\") throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for(let i = 0; i < halfRoundsFull; i++)values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for(let i = 0; i < roundsPartial; i++)values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for(let i = 0; i < halfRoundsFull; i++)values = poseidonRound(values, true, round++);\n        if (round !== rounds) throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n} //# sourceMappingURL=poseidon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvcG9zZWlkb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSxzRkFBc0Y7QUFDbEM7QUFDN0MsU0FBU0UsYUFBYUMsSUFBSTtJQUM3QixNQUFNLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxzQkFBc0JDLEdBQUcsRUFBRUMsZ0JBQWdCQyxFQUFFLEVBQUUsR0FBR047SUFDbkUsTUFBTSxFQUFFTyxVQUFVLEVBQUVDLGFBQWEsRUFBRUMsU0FBUyxFQUFFQyxDQUFDLEVBQUUsR0FBR1Y7SUFDcERGLDBEQUFhQSxDQUFDRztJQUNkLEtBQUssTUFBTVUsS0FBSztRQUFDO1FBQUs7UUFBYztLQUFnQixDQUFFO1FBQ2xELElBQUksT0FBT1gsSUFBSSxDQUFDVyxFQUFFLEtBQUssWUFBWSxDQUFDQyxPQUFPQyxhQUFhLENBQUNiLElBQUksQ0FBQ1csRUFBRSxHQUM1RCxNQUFNLElBQUlHLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUgsRUFBRSxDQUFDLEVBQUVYLElBQUksQ0FBQ1csRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPWCxJQUFJLENBQUNXLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckY7SUFDQSxvQkFBb0I7SUFDcEIsSUFBSSxDQUFDSSxNQUFNQyxPQUFPLENBQUNkLFFBQVFBLElBQUllLE1BQU0sS0FBS1AsR0FDdEMsTUFBTSxJQUFJSSxNQUFNO0lBQ3BCLE1BQU1JLE9BQU9oQixJQUFJaUIsR0FBRyxDQUFDLENBQUNDO1FBQ2xCLElBQUksQ0FBQ0wsTUFBTUMsT0FBTyxDQUFDSSxXQUFXQSxPQUFPSCxNQUFNLEtBQUtQLEdBQzVDLE1BQU0sSUFBSUksTUFBTSxDQUFDLHlCQUF5QixFQUFFTSxPQUFPLENBQUM7UUFDeEQsT0FBT0EsT0FBT0QsR0FBRyxDQUFDLENBQUNSO1lBQ2Ys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QU1VO1FBQ3pDLDRCQUE0QjtRQUM1QixJQUFLLElBQUkxQyxJQUFJLEdBQUdBLElBQUlILGVBQWVHLElBQy9CZ0MsU0FBU0QsY0FBY0MsUUFBUSxPQUFPVTtRQUMxQywyQkFBMkI7UUFDM0IsSUFBSyxJQUFJMUMsSUFBSSxHQUFHQSxJQUFJNkIsZ0JBQWdCN0IsSUFDaENnQyxTQUFTRCxjQUFjQyxRQUFRLE1BQU1VO1FBQ3pDLElBQUlBLFVBQVU5QixRQUNWLE1BQU0sSUFBSVQsTUFBTSxDQUFDLDZDQUE2QyxFQUFFdUMsTUFBTSxRQUFRLEVBQUU5QixPQUFPLENBQUM7UUFDNUYsT0FBT29CO0lBQ1g7SUFDQSw0QkFBNEI7SUFDNUJTLGFBQWEvQyxjQUFjLEdBQUdBO0lBQzlCLE9BQU8rQztBQUNYLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjMjBfd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS4yLjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzPzMyNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gUG9zZWlkb24gSGFzaDogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80NTgucGRmLCBodHRwczovL3d3dy5wb3NlaWRvbi1oYXNoLmluZm9cbmltcG9ydCB7IEZwUG93LCB2YWxpZGF0ZUZpZWxkIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9wdHMob3B0cykge1xuICAgIGNvbnN0IHsgRnAsIG1kcywgcmV2ZXJzZVBhcnRpYWxQb3dJZHg6IHJldiwgcm91bmRDb25zdGFudHM6IHJjIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgcm91bmRzRnVsbCwgcm91bmRzUGFydGlhbCwgc2JveFBvd2VyLCB0IH0gPSBvcHRzO1xuICAgIHZhbGlkYXRlRmllbGQoRnApO1xuICAgIGZvciAoY29uc3QgaSBvZiBbJ3QnLCAncm91bmRzRnVsbCcsICdyb3VuZHNQYXJ0aWFsJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzW2ldICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob3B0c1tpXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiBpbnZhbGlkIHBhcmFtICR7aX09JHtvcHRzW2ldfSAoJHt0eXBlb2Ygb3B0c1tpXX0pYCk7XG4gICAgfVxuICAgIC8vIE1EUyBpcyBUeFQgbWF0cml4XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1kcykgfHwgbWRzLmxlbmd0aCAhPT0gdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NlaWRvbjogd3JvbmcgTURTIG1hdHJpeCcpO1xuICAgIGNvbnN0IF9tZHMgPSBtZHMubWFwKChtZHNSb3cpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1kc1JvdykgfHwgbWRzUm93Lmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gTURTIG1hdHJpeCByb3c6ICR7bWRzUm93fWApO1xuICAgICAgICByZXR1cm4gbWRzUm93Lm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIE1EUyBtYXRyaXggdmFsdWU9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJldiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXYgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogaW52YWxpZCBwYXJhbSByZXZlcnNlUGFydGlhbFBvd0lkeD0ke3Jldn1gKTtcbiAgICBpZiAocm91bmRzRnVsbCAlIDIgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gcm91bmRzRnVsbCBpcyBub3QgZXZlbjogJHtyb3VuZHNGdWxsfWApO1xuICAgIGNvbnN0IHJvdW5kcyA9IHJvdW5kc0Z1bGwgKyByb3VuZHNQYXJ0aWFsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICE9PSByb3VuZHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIHJvdW5kIGNvbnN0YW50cycpO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gcmMubWFwKChyYykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgcm91bmQgY29uc3RhbnRzOiAke3JjfWApO1xuICAgICAgICByZXR1cm4gcmMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnIHx8ICFGcC5pc1ZhbGlkKGkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgcm91bmQgY29uc3RhbnQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFzYm94UG93ZXIgfHwgIVszLCA1LCA3XS5pbmNsdWRlcyhzYm94UG93ZXIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHNib3hQb3dlcj0ke3Nib3hQb3dlcn1gKTtcbiAgICBjb25zdCBfc2JveFBvd2VyID0gQmlnSW50KHNib3hQb3dlcik7XG4gICAgbGV0IHNib3hGbiA9IChuKSA9PiBGcFBvdyhGcCwgbiwgX3Nib3hQb3dlcik7XG4gICAgLy8gVW53cmFwcGVkIHNib3ggcG93ZXIgZm9yIGNvbW1vbiBjYXNlcyAoMTk1LT4xNDLOvHMpXG4gICAgaWYgKHNib3hQb3dlciA9PT0gMylcbiAgICAgICAgc2JveEZuID0gKG4pID0+IEZwLm11bChGcC5zcXJOKG4pLCBuKTtcbiAgICBlbHNlIGlmIChzYm94UG93ZXIgPT09IDUpXG4gICAgICAgIHNib3hGbiA9IChuKSA9PiBGcC5tdWwoRnAuc3FyTihGcC5zcXJOKG4pKSwgbik7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzLCByb3VuZHMsIHNib3hGbiwgcm91bmRDb25zdGFudHMsIG1kczogX21kcyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdENvbnN0YW50cyhyYywgdCkge1xuICAgIGlmICh0eXBlb2YgdCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zZWlkb25TcGxpdENvbnN0YW50czogd3JvbmcgdCcpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICUgdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NlaWRvblNwbGl0Q29uc3RhbnRzOiB3cm9uZyByYycpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCB0bXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRtcC5wdXNoKHJjW2ldKTtcbiAgICAgICAgaWYgKHRtcC5sZW5ndGggPT09IHQpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRtcCk7XG4gICAgICAgICAgICB0bXAgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uKG9wdHMpIHtcbiAgICBjb25zdCBfb3B0cyA9IHZhbGlkYXRlT3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwLCBtZHMsIHJvdW5kQ29uc3RhbnRzLCByb3VuZHMsIHJvdW5kc1BhcnRpYWwsIHNib3hGbiwgdCB9ID0gX29wdHM7XG4gICAgY29uc3QgaGFsZlJvdW5kc0Z1bGwgPSBfb3B0cy5yb3VuZHNGdWxsIC8gMjtcbiAgICBjb25zdCBwYXJ0aWFsSWR4ID0gX29wdHMucmV2ZXJzZVBhcnRpYWxQb3dJZHggPyB0IC0gMSA6IDA7XG4gICAgY29uc3QgcG9zZWlkb25Sb3VuZCA9ICh2YWx1ZXMsIGlzRnVsbCwgaWR4KSA9PiB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGksIGopID0+IEZwLmFkZChpLCByb3VuZENvbnN0YW50c1tpZHhdW2pdKSk7XG4gICAgICAgIGlmIChpc0Z1bGwpXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpKSA9PiBzYm94Rm4oaSkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWx1ZXNbcGFydGlhbElkeF0gPSBzYm94Rm4odmFsdWVzW3BhcnRpYWxJZHhdKTtcbiAgICAgICAgLy8gTWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIHZhbHVlcyA9IG1kcy5tYXAoKGkpID0+IGkucmVkdWNlKChhY2MsIGksIGopID0+IEZwLmFkZChhY2MsIEZwLm11bE4oaSwgdmFsdWVzW2pdKSksIEZwLlpFUk8pKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIGNvbnN0IHBvc2VpZG9uSGFzaCA9IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaCh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIHZhbHVlcyAoZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cyB3aXRoIGxlbmd0aCAke3R9KWApO1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIHZhbHVlPSR7aX0gKCR7dHlwZW9mIGl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByb3VuZCA9IDA7XG4gICAgICAgIC8vIEFwcGx5IHJfZi8yIGZ1bGwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGZSb3VuZHNGdWxsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgdHJ1ZSwgcm91bmQrKyk7XG4gICAgICAgIC8vIEFwcGx5IHJfcCBwYXJ0aWFsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHNQYXJ0aWFsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgZmFsc2UsIHJvdW5kKyspO1xuICAgICAgICAvLyBBcHBseSByX2YvMiBmdWxsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICBpZiAocm91bmQgIT09IHJvdW5kcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIG51bWJlciBvZiByb3VuZHM6IGxhc3Qgcm91bmQ9JHtyb3VuZH0sIHRvdGFsPSR7cm91bmRzfWApO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgLy8gRm9yIHZlcmlmaWNhdGlvbiBpbiB0ZXN0c1xuICAgIHBvc2VpZG9uSGFzaC5yb3VuZENvbnN0YW50cyA9IHJvdW5kQ29uc3RhbnRzO1xuICAgIHJldHVybiBwb3NlaWRvbkhhc2g7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3NlaWRvbi5qcy5tYXAiXSwibmFtZXMiOlsiRnBQb3ciLCJ2YWxpZGF0ZUZpZWxkIiwidmFsaWRhdGVPcHRzIiwib3B0cyIsIkZwIiwibWRzIiwicmV2ZXJzZVBhcnRpYWxQb3dJZHgiLCJyZXYiLCJyb3VuZENvbnN0YW50cyIsInJjIiwicm91bmRzRnVsbCIsInJvdW5kc1BhcnRpYWwiLCJzYm94UG93ZXIiLCJ0IiwiaSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIl9tZHMiLCJtYXAiLCJtZHNSb3ciLCJjcmVhdGUiLCJ1bmRlZmluZWQiLCJyb3VuZHMiLCJpc1ZhbGlkIiwiaW5jbHVkZXMiLCJfc2JveFBvd2VyIiwiQmlnSW50Iiwic2JveEZuIiwibiIsIm11bCIsInNxck4iLCJPYmplY3QiLCJmcmVlemUiLCJzcGxpdENvbnN0YW50cyIsInJlcyIsInRtcCIsInB1c2giLCJwb3NlaWRvbiIsIl9vcHRzIiwiaGFsZlJvdW5kc0Z1bGwiLCJwYXJ0aWFsSWR4IiwicG9zZWlkb25Sb3VuZCIsInZhbHVlcyIsImlzRnVsbCIsImlkeCIsImoiLCJhZGQiLCJyZWR1Y2UiLCJhY2MiLCJtdWxOIiwiWkVSTyIsInBvc2VpZG9uSGFzaCIsInJvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/poseidon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwRUFBMEU7QUFDMUUsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRSx1Q0FBdUM7QUFDdkMsTUFBTUEsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTSxDQUFDQyxJQUFNQSxhQUFhQztBQUNoQyxNQUFNQyxRQUFRLGFBQWEsR0FBR0MsTUFBTUMsSUFBSSxDQUFDO0lBQUVDLFFBQVE7QUFBSSxHQUFHLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztBQUMvRjs7Q0FFQyxHQUNNLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsSUFBSSxDQUFDWixJQUFJWSxRQUNMLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixvQ0FBb0M7SUFDcEMsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJSSxNQUFNTixNQUFNLEVBQUVFLElBQUs7UUFDbkNNLE9BQU9YLEtBQUssQ0FBQ1MsS0FBSyxDQUFDSixFQUFFLENBQUM7SUFDMUI7SUFDQSxPQUFPTTtBQUNYO0FBQ08sU0FBU0Msb0JBQW9CQyxHQUFHO0lBQ25DLE1BQU1GLE1BQU1FLElBQUlQLFFBQVEsQ0FBQztJQUN6QixPQUFPSyxJQUFJUixNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRVEsSUFBSSxDQUFDLEdBQUdBO0FBQ3hDO0FBQ08sU0FBU0csWUFBWUgsR0FBRztJQUMzQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlELE1BQU0sOEJBQThCLE9BQU9DO0lBQ3pELGFBQWE7SUFDYixPQUFPakIs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QUFNQyxXQUFXdEIsWUFBWSxDQUFDb0IsS0FBSztRQUNuQyxJQUFJLE9BQU9FLGFBQWEsWUFDcEIsTUFBTSxJQUFJN0YsTUFBTSxDQUFDLG1CQUFtQixFQUFFMkYsS0FBSyxvQkFBb0IsQ0FBQztRQUNwRSxNQUFNbEIsTUFBTVEsTUFBTSxDQUFDUyxVQUFVO1FBQzdCLElBQUlFLGNBQWNuQixRQUFRSCxXQUN0QjtRQUNKLElBQUksQ0FBQ3VCLFNBQVNwQixLQUFLUSxTQUFTO1lBQ3hCLE1BQU0sSUFBSWpGLE1BQU0sQ0FBQyxjQUFjLEVBQUU4RixPQUFPSixXQUFXLENBQUMsRUFBRWpCLElBQUksRUFBRSxFQUFFLE9BQU9BLElBQUksWUFBWSxFQUFFa0IsS0FBSyxDQUFDO1FBQ2pHO0lBQ0o7SUFDQSxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJSSxPQUFPQyxPQUFPLENBQUNULFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1IsZUFDM0NDLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsT0FBT1Y7QUFDWCxFQUNBLHNCQUFzQjtDQUN0Qix1RUFBdUU7Q0FDdkUsZ0ZBQWdGO0NBQ2hGLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0QscUVBQXFFO0NBQ3JFLCtEQUErRDtDQUMvRCw0REFBNEQ7Q0FDNUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjMjBfd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS4yLjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzNkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwidThhIiwiYSIsIlVpbnQ4QXJyYXkiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsIkVycm9yIiwiaGV4IiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleFRvTnVtYmVyIiwiaGV4VG9CeXRlcyIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsInRpdGxlIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJyIiwicmVkdWNlIiwic3VtIiwicGFkIiwiZm9yRWFjaCIsInNldCIsImVxdWFsQnl0ZXMiLCJiMSIsImIyIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJpdExlbiIsImJpdEdldCIsInBvcyIsImJpdFNldCIsInZhbHVlIiwiYml0TWFzayIsInU4biIsImRhdGEiLCJ1OGZyIiwiYXJyIiwiY3JlYXRlSG1hY0RyYmciLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJiIiwicmVzZWVkIiwic2VlZCIsImdlbiIsIm91dCIsInNsIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInVuZGVmaW5lZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiT2JqZWN0IiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsNERBQTREO0FBQ3hCO0FBQ0g7QUFDUTtBQUNRO0FBQ2pELFNBQVNLLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPSCx3REFBYUEsQ0FBQ0U7SUFDM0JMLHFEQUFpQixDQUFDTSxNQUFNO1FBQ3BCRSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHRjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR25CLElBQUk7SUFBQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQixNQUFNLEVBQUVvQixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMsR0FBRyxFQUFFLEdBQUc3QixzQ0FBRUE7QUFDN0MsTUFBTThCLE1BQU07SUFDZiwyQkFBMkI7SUFDM0JDLEtBQUssTUFBTUMsZUFBZVg7UUFDdEJZLFlBQVlDLElBQUksRUFBRSxDQUFFO1lBQ2hCLEtBQUssQ0FBQ0E7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QUcsQ0FBQ21PLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEMU8sSUFBSTVELEdBQUdvRSxHQUFHLENBQUNSLEdBQUdvUCxRQUFRLG1CQUFtQjtRQUN6Q3JQLElBQUkzRCxHQUFHNlMsSUFBSSxDQUFDbFAsR0FBRzhPLEtBQUs5TSxVQUFVLHdDQUF3QztRQUN0RS9CLElBQUk1RCxHQUFHNlMsSUFBSSxDQUFDalAsR0FBR29QLE9BQU9yTixVQUFVLHVDQUF1QztRQUN2RSxNQUFNb04sS0FBSy9TLEdBQUdvSCxLQUFLLENBQUNrTCxPQUFPdFMsR0FBR29ILEtBQUssQ0FBQ3hELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJNUQsR0FBRzZTLElBQUksQ0FBQzdTLEdBQUcrSCxHQUFHLENBQUNuRSxJQUFJQSxHQUFHbVAsS0FBSyw0QkFBNEI7UUFDM0RwUCxJQUFJM0QsR0FBR3VULEdBQUcsQ0FBQzVQLEdBQUdnUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVoUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lcmMyMF93ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/MGEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyB3cm9uZyByZXByZXNlbnRhdGlvbiBvZiBaRVJPIGFuZCBpcyBhbHdheXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2QiLCJ1dCIsImVuc3VyZUJ5dGVzIiwid05BRiIsInZhbGlkYXRlQmFzaWMiLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwib3B0cyIsInZhbGlkYXRlT2JqZWN0IiwiYSIsImIiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJ3cmFwUHJpdmF0ZUtleSIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiYWxsb3dJbmZpbml0eVBvaW50IiwiZnJvbUJ5dGVzIiwidG9CeXRlcyIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsIk9iamVjdCIsImZyZWV6ZSIsImJ5dGVzVG9OdW1iZXJCRSIsImIybiIsImhleFRvQnl0ZXMiLCJoMmIiLCJERVIiLCJFcnIiLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJfcGFyc2VJbnQiLCJkYXRhIiwiRSIsImxlbmd0aCIsImxlbiIsInJlcyIsInN1YmFycmF5IiwiZCIsImwiLCJ0b1NpZyIsImhleCIsIlVpbnQ4QXJyYXkiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsIkd5IiwiR3giLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJuIiwiYXNzZXJ0R0UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiYnl0ZXNUb0hleCIsImluY2x1ZGVzIiwicGFkU3RhcnQiLCJlcnJvciIsInBvaW50UHJlY29tcHV0ZXMiLCJNYXAiLCJhc3NlcnRQcmpQb2ludCIsIm90aGVyIiwiUG9pbnQiLCJweCIsInB5IiwicHoiLCJpc1ZhbGlkIiwiZnJvbUFmZmluZSIsInAiLCJpczAiLCJpIiwiT05FIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwiaW52ZXJ0QmF0Y2giLCJtYXAiLCJmcm9tSGV4IiwiUCIsImFzc2VydFZhbGlkaXR5IiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiQkFTRSIsIm11bHRpcGx5IiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwiX1dJTkRPV19TSVpFIiwiZGVsZXRlIiwibGVmdCIsInJpZ2h0IiwiaGFzRXZlblkiLCJpc09kZCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJuZWdhdGUiLCJuZWciLCJkb3VibGUiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MiIsInQzIiwic3ViIiwidDQiLCJ0NSIsInN1YnRyYWN0Iiwid25hZiIsIndOQUZDYWNoZWQiLCJjb21wIiwibXVsdGlwbHlVbnNhZmUiLCJJIiwidW5zYWZlTGFkZGVyIiwiazFuZWciLCJrMSIsImsybmVnIiwiazIiLCJrMXAiLCJrMnAiLCJzY2FsYXIiLCJmYWtlIiwiZiIsImYxcCIsImYycCIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwiUSIsIkciLCJzdW0iLCJ1bmRlZmluZWQiLCJpeiIsInoiLCJpbnYiLCJheCIsImF5IiwienoiLCJjb2ZhY3RvciIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJ0b0hleCIsIl9iaXRzIiwibkJpdExlbmd0aCIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsImxvd1MiLCJ3ZWllcnN0cmFzcyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaXNWYWxpZEZpZWxkRWxlbWVudCIsIk9SREVSIiwibW9kTiIsImludk4iLCJpbnZlcnQiLCJjYXQiLCJoZWFkIiwieTIiLCJzcXJ0IiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJtZXNzYWdlIiwiaXMiLCJ2IiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJwb3ciLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwidmFsaWRhdGVGaWVsZCIsIkEiLCJCIiwidHY2IiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ })

};
;