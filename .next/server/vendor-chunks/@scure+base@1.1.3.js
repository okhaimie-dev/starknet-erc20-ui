"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure+base@1.1.3";
exports.ids = ["vendor-chunks/@scure+base@1.1.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@scure+base@1.1.3/node_modules/@scure/base/lib/esm/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@scure+base@1.1.3/node_modules/@scure/base/lib/esm/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args).reverse().reduce((acc, i)=>acc ? wrap(acc, i.encode) : i.encode, undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i)=>acc ? wrap(acc, i.decode) : i.decode, undefined);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nconst base58 = /* @__PURE__ */ genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = /* @__PURE__ */ genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = /* @__PURE__ */ genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst base58check = /* @__PURE__ */ (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode,\n        decode,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32(\"bech32\");\nconst bech32m = /* @__PURE__ */ genBech32(\"bech32m\");\nconst utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNjdXJlK2Jhc2VAMS4xLjMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRSxHQUNsRSxZQUFZO0FBQ1o7O0NBRUMsR0FDTSxTQUFTQSxhQUFhQyxDQUFDO0lBQzFCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixJQUN0QixNQUFNLElBQUlHLE1BQU0sQ0FBQyxlQUFlLEVBQUVILEVBQUUsQ0FBQztBQUM3QztBQUNBOztDQUVDLEdBQ0QsU0FBU0ksTUFBTSxHQUFHQyxJQUFJO0lBQ2xCLCtDQUErQztJQUMvQyxNQUFNQyxPQUFPLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0MsSUFBTUYsRUFBRUMsRUFBRUM7SUFDbEMsNkRBQTZEO0lBQzdELE1BQU1DLFNBQVNDLE1BQU1DLElBQUksQ0FBQ1AsTUFDckJRLE9BQU8sR0FDUEMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU9ELE1BQU1ULEtBQUtTLEtBQUtDLEVBQUVOLE1BQU0sSUFBSU0sRUFBRU4sTUFBTSxFQUFHTztJQUNoRSx5REFBeUQ7SUFDekQsTUFBTUMsU0FBU2IsS0FBS1MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU9ELE1BQU1ULEtBQUtTLEtBQUtDLEVBQUVFLE1BQU0sSUFBSUYsRUFBRUUsTUFBTSxFQUFHRDtJQUMvRSxPQUFPO1FBQUVQO1FBQVFRO0lBQU87QUFDNUI7QUFDQTs7O0NBR0MsR0FDRCxTQUFTQyxTQUFTQSxRQUFRO0lBQ3RCLE9BQU87UUFDSFQsUUFBUSxDQUFDVTtZQUNMLElBQUksQ0FBQ1QsTUFBTVUsT0FBTyxDQUFDRCxXQUFZQSxPQUFPRSxNQUFNLElBQUksT0FBT0YsTUFBTSxDQUFDLEVBQUUsS0FBSyxVQUNqRSxNQUFNLElBQUlqQixNQUFNO1lBQ3BCLE9BQU9pQixPQUFPRyxHQUFHLENBQUMsQ0FBQ1A7Z0JB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QUFNLENBQUMsQ0FBQztJQUM5RixPQUFPdUQsRUFBRTRDLFdBQVc7QUFDeEIsSUFBSTtBQUNKLGtCQUFrQjtBQUNsQixNQUFNYSxTQUFTO0lBQ1hKO0lBQU1HO0lBQUs1RDtJQUFRQztJQUFRTTtJQUFRQztJQUFXSTtJQUFRSTtBQUMxRDtBQUNBLE1BQU04QyxpQkFBaUI7QUFDaEIsTUFBTUMsZ0JBQWdCLENBQUNDLE1BQU05RTtJQUNoQyxJQUFJLE9BQU84RSxTQUFTLFlBQVksQ0FBQ0gsT0FBT0ksY0FBYyxDQUFDRCxPQUNuRCxNQUFNLElBQUlsQixVQUFVZ0I7SUFDeEIsSUFBSSxDQUFFNUUsQ0FBQUEsaUJBQWlCQyxVQUFTLEdBQzVCLE1BQU0sSUFBSTJELFVBQVU7SUFDeEIsT0FBT2UsTUFBTSxDQUFDRyxLQUFLLENBQUMvSCxNQUFNLENBQUNpRDtBQUMvQixFQUFFO0FBQ0ssTUFBTWtDLE1BQU0yQyxjQUFjLENBQUMsbUNBQW1DO0FBQzlELE1BQU1HLGdCQUFnQixDQUFDRixNQUFNNUM7SUFDaEMsSUFBSSxDQUFDeUMsT0FBT0ksY0FBYyxDQUFDRCxPQUN2QixNQUFNLElBQUlsQixVQUFVZ0I7SUFDeEIsSUFBSSxPQUFPMUMsUUFBUSxVQUNmLE1BQU0sSUFBSTBCLFVBQVU7SUFDeEIsT0FBT2UsTUFBTSxDQUFDRyxLQUFLLENBQUN2SCxNQUFNLENBQUMyRTtBQUMvQixFQUFFO0FBQ0ssTUFBTWxDLFFBQVFnRixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXJjMjBfd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzY3VyZStiYXNlQDEuMS4zL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzPzIzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllc1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7IGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcgfTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgY29uc3QgYmFzZTE2ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybG5vcGFkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgam9pbignJykpO1xuLy8gYmFzZTU4IGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5jb25zdCBnZW5CYXNlNTggPSAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNTggPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonKTtcbi8vIHhtciB2ZXIgaXMgZG9uZSBpbiA4LWJ5dGUgYmxvY2tzICh3aGljaCBlcXVhbHMgMTEgY2hhcnMgaW4gZGVjb2RpbmcpLiBMYXN0IChub24tZnVsbCkgYmxvY2sgcGFkZGVkIHdpdGggJzEnIHRvIHNpemUgaW4gWE1SX0JMT0NLX0xFTi5cbi8vIEJsb2NrIGVuY29kaW5nIHNpZ25pZmljYW50bHkgcmVkdWNlcyBxdWFkcmF0aWMgY29tcGxleGl0eSBvZiBiYXNlNTguXG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IC8qIEBfX1BVUkVfXyAqLyAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnQgY29uc3QgaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9ICdJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yJztcbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBzdHIgPSBieXRlc1RvU3RyaW5nOyAvLyBhcyBpbiBweXRob24sIGJ1dCBmb3IgYnl0ZXMgb25seVxuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuIl0sIm5hbWVzIjpbImFzc2VydE51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJjaGFpbiIsImFyZ3MiLCJ3cmFwIiwiYSIsImIiLCJjIiwiZW5jb2RlIiwiQXJyYXkiLCJmcm9tIiwicmV2ZXJzZSIsInJlZHVjZSIsImFjYyIsImkiLCJ1bmRlZmluZWQiLCJkZWNvZGUiLCJhbHBoYWJldCIsImRpZ2l0cyIsImlzQXJyYXkiLCJsZW5ndGgiLCJtYXAiLCJpbnB1dCIsImxldHRlciIsImluZGV4IiwiaW5kZXhPZiIsImpvaW4iLCJzZXBhcmF0b3IiLCJ0byIsInNwbGl0IiwicGFkZGluZyIsImJpdHMiLCJjaHIiLCJkYXRhIiwicHVzaCIsImVuZCIsInNsaWNlIiwibm9ybWFsaXplIiwiZm4iLCJjb252ZXJ0UmFkaXgiLCJwb3MiLCJyZXMiLCJmb3JFYWNoIiwiZCIsImNhcnJ5IiwiZG9uZSIsImRpZ2l0IiwiZGlnaXRCYXNlIiwicm91bmRlZCIsIk1hdGgiLCJmbG9vciIsImdjZCIsInJhZGl4MmNhcnJ5IiwiY29udmVydFJhZGl4MiIsIm1hc2siLCJyYWRpeCIsIm51bSIsImJ5dGVzIiwiVWludDhBcnJheSIsInJhZGl4MiIsInJldlBhZGRpbmciLCJ1bnNhZmVXcmFwcGVyIiwiYXBwbHkiLCJlIiwiY2hlY2tzdW0iLCJsZW4iLCJzZXQiLCJwYXlsb2FkIiwibmV3Q2hlY2tzdW0iLCJvbGRDaGVja3N1bSIsInV0aWxzIiwiYmFzZTE2IiwiYmFzZTMyIiwiYmFzZTMyaGV4IiwiYmFzZTMyY3JvY2tmb3JkIiwicyIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsImJhc2U2NCIsImJhc2U2NHVybCIsImJhc2U2NHVybG5vcGFkIiwiZ2VuQmFzZTU4IiwiYWJjIiwiYmFzZTU4IiwiYmFzZTU4ZmxpY2tyIiwiYmFzZTU4eHJwIiwiWE1SX0JMT0NLX0xFTiIsImJhc2U1OHhtciIsImJsb2NrIiwic3ViYXJyYXkiLCJwYWRTdGFydCIsInN0ciIsImJsb2NrTGVuIiwiaiIsImNvbmNhdCIsImJhc2U1OGNoZWNrIiwic2hhMjU2IiwiQkVDSF9BTFBIQUJFVCIsIlBPTFlNT0RfR0VORVJBVE9SUyIsImJlY2gzMlBvbHltb2QiLCJwcmUiLCJjaGsiLCJiZWNoQ2hlY2tzdW0iLCJwcmVmaXgiLCJ3b3JkcyIsImVuY29kaW5nQ29uc3QiLCJjaGFyQ29kZUF0IiwidiIsImdlbkJlY2gzMiIsImVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJfd29yZHMiLCJmcm9tV29yZHMiLCJ0b1dvcmRzIiwiZnJvbVdvcmRzVW5zYWZlIiwibGltaXQiLCJhY3R1YWxMZW5ndGgiLCJUeXBlRXJyb3IiLCJsb3dlcmVkIiwidG9Mb3dlckNhc2UiLCJzdW0iLCJzZXBJbmRleCIsImxhc3RJbmRleE9mIiwiZW5kc1dpdGgiLCJkZWNvZGVVbnNhZmUiLCJkZWNvZGVUb0J5dGVzIiwiYmVjaDMyIiwiYmVjaDMybSIsInV0ZjgiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiaGV4IiwiQ09ERVJTIiwiY29kZXJUeXBlRXJyb3IiLCJieXRlc1RvU3RyaW5nIiwidHlwZSIsImhhc093blByb3BlcnR5Iiwic3RyaW5nVG9CeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@scure+base@1.1.3/node_modules/@scure/base/lib/esm/index.js\n");

/***/ })

};
;